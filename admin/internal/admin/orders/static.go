package orders

import (
	"context"
	"fmt"
	"net/mail"
	"sort"
	"strings"
	"sync"
	"time"
)

// StaticService provides deterministic order data suitable for local development and tests.
type StaticService struct {
	mu               sync.RWMutex
	orders           []Order
	timelines        map[string][]TimelineEvent
	invoiceJobs      map[string]*invoiceJobState
	exportJobs       map[string]*exportJobState
	invoiceTemplates []InvoiceTemplate
	invoiceLanguages []InvoiceLanguage
	audit            AuditLogger
}

// NewStaticService returns a StaticService populated with representative orders.
func NewStaticService() *StaticService {
	now := time.Now()

	ptrTime := func(t time.Time) *time.Time {
		return &t
	}

	makePaymentDetail := func(id, provider, method, last4, reference, status, tone, currency string, authorized, captured, refunded int64, capturedAt *time.Time) PaymentDetail {
		if strings.TrimSpace(provider) == "" {
			provider = "Stripe"
		}
		if strings.TrimSpace(method) == "" {
			method = "„ÇØ„É¨„Ç∏„ÉÉ„Éà„Ç´„Éº„Éâ"
		}
		if strings.TrimSpace(reference) == "" {
			reference = id
		}
		if strings.TrimSpace(status) == "" {
			status = "ÊîØÊâï„ÅÑÊ∏à„Åø"
		}
		if strings.TrimSpace(currency) == "" {
			currency = "JPY"
		}
		if authorized < captured {
			authorized = captured
		}
		available := captured - refunded
		if available < 0 {
			available = 0
		}
		if refunded < 0 {
			refunded = 0
		}
		return PaymentDetail{
			ID:               strings.TrimSpace(id),
			Provider:         strings.TrimSpace(provider),
			Method:           strings.TrimSpace(method),
			Last4:            strings.TrimSpace(last4),
			Reference:        strings.TrimSpace(reference),
			Status:           strings.TrimSpace(status),
			StatusTone:       strings.TrimSpace(tone),
			Currency:         strings.TrimSpace(currency),
			AmountAuthorized: authorized,
			AmountCaptured:   captured,
			AmountRefunded:   refunded,
			AmountAvailable:  available,
			CapturedAt:       capturedAt,
		}
	}

	makeRefundRecord := func(id, paymentID string, amount int64, currency, reason, status, actor string, processed time.Time) RefundRecord {
		if strings.TrimSpace(id) == "" {
			id = fmt.Sprintf("refund_%s_%d", paymentID, processed.Unix())
		}
		if processed.IsZero() {
			processed = time.Now()
		}
		if strings.TrimSpace(status) == "" {
			status = "succeeded"
		}
		if strings.TrimSpace(currency) == "" {
			currency = "JPY"
		}
		if strings.TrimSpace(actor) == "" {
			actor = "„Ç™„Éö„É¨„Éº„Çø„Éº"
		}
		return RefundRecord{
			ID:          strings.TrimSpace(id),
			PaymentID:   strings.TrimSpace(paymentID),
			AmountMinor: amount,
			Currency:    strings.TrimSpace(currency),
			Reason:      strings.TrimSpace(reason),
			Status:      strings.TrimSpace(status),
			ProcessedAt: processed,
			Actor:       strings.TrimSpace(actor),
			Reference:   fmt.Sprintf("%s-ref", strings.TrimSpace(id)),
		}
	}

	makeOrder := func(base Order) Order {
		// Ensure derived fields like status label/tone are populated when omitted.
		if strings.TrimSpace(base.StatusLabel) == "" {
			base.StatusLabel = defaultStatusLabel(base.Status)
		}
		if strings.TrimSpace(base.StatusTone) == "" {
			base.StatusTone = defaultStatusTone(base.Status)
		}
		return base
	}

	orders := []Order{
		makeOrder(Order{
			ID:          "order-1052",
			Number:      "1052",
			CreatedAt:   now.Add(-9 * time.Hour),
			UpdatedAt:   now.Add(-32 * time.Minute),
			Customer:    Customer{ID: "cust-8721", Name: "Èï∑Ë∞∑Â∑ù Á¥î", Email: "jun.hasegawa@example.com"},
			TotalMinor:  3200000,
			Currency:    "JPY",
			Status:      StatusInProduction,
			StatusLabel: "Âà∂‰Ωú‰∏≠",
			Fulfillment: Fulfillment{
				Method:        "ÂàªÂç∞Â∑•Êàø",
				Carrier:       "Â∑•ÊàøÂá∫Ëç∑",
				PromisedDate:  ptrTime(now.Add(36 * time.Hour)),
				SLAStatus:     "Âà∂‰ΩúÊÆã„Çä 12 ÊôÇÈñì",
				SLAStatusTone: "info",
			},
			Payment: Payment{
				Status:     "ÊîØÊâï„ÅÑÊ∏à„Åø",
				StatusTone: "success",
				CapturedAt: ptrTime(now.Add(-8 * time.Hour)),
			},
			Payments: []PaymentDetail{
				makePaymentDetail(
					"pay-1052",
					"Stripe",
					"„ÇØ„É¨„Ç∏„ÉÉ„Éà„Ç´„Éº„Éâ",
					"4242",
					"pay_1052",
					"ÊîØÊâï„ÅÑÊ∏à„Åø",
					"success",
					"JPY",
					3200000,
					3200000,
					0,
					ptrTime(now.Add(-8*time.Hour)),
				),
			},
			Tags:         []string{"ÂàªÂç∞„É™„É≥„Ç∞", "B2C"},
			Badges:       []Badge{{Label: "ÂÑ™ÂÖàÂà∂‰Ωú", Tone: "warning", Icon: "‚ö°"}, {Label: "VIPÈ°ßÂÆ¢", Tone: "info", Icon: "üëë"}},
			ItemsSummary: "ÂàªÂç∞„É™„É≥„Ç∞Ôºà18KÔºâ √ó 2 / „Ç´„Çπ„Çø„É†ÂàªÂç∞",
			Notes:        []string{"ÂàªÂç∞„Éï„Ç©„É≥„Éà: S-12", "Á¥çÊúüÁü≠Á∏Æ„ÅÆÂ∏åÊúõ„ÅÇ„Çä"},
			SalesChannel: "„Ç™„É≥„É©„Ç§„É≥„Çπ„Éà„Ç¢",
			Integration:  "Shopify",
		}),
		makeOrder(Order{
			ID:          "order-1051",
			Number:      "1051",
			CreatedAt:   now.Add(-13 * time.Hour),
			UpdatedAt:   now.Add(-1 * time.Hour),
			Customer:    Customer{ID: "cust-8012", Name: "ÈùíÊú® ÈáåÂ•à", Email: "rina.aoki@example.com"},
			TotalMinor:  1280000,
			Currency:    "JPY",
			Status:      StatusReadyToShip,
			StatusLabel: "Âá∫Ëç∑ÂæÖ„Å°",
			Fulfillment: Fulfillment{
				Method:        "ÂÆÖÈÖç‰æø",
				Carrier:       "„É§„Éû„ÉàÈÅãËº∏",
				PromisedDate:  ptrTime(now.Add(18 * time.Hour)),
				SLAStatus:     "„Éî„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÂæÖ„Å°",
				SLAStatusTone: "warning",
			},
			Payment: Payment{
				Status:     "ÊîØÊâï„ÅÑÊ∏à„Åø",
				StatusTone: "success",
				CapturedAt: ptrTime(now.Add(-10 * time.Hour)),
			},
			Payments: []PaymentDetail{
				makePaymentDetail(
					"pay-1051",
					"Stripe",
					"„ÇØ„É¨„Ç∏„ÉÉ„Éà„Ç´„Éº„Éâ",
					"1881",
					"pay_1051",
					"ÊîØÊâï„ÅÑÊ∏à„Åø",
					"success",
					"JPY",
					1280000,
					1280000,
					0,
					ptrTime(now.Add(-10*time.Hour)),
				),
			},
			Tags:         []string{"„Éç„ÉÉ„ÇØ„É¨„Çπ", "Âú®Â∫´"},
			Badges:       []Badge{{Label: "„ÇÆ„Éï„ÉàÂåÖË£Ö", Tone: "info", Icon: "üéÅ"}},
			ItemsSummary: "„Éö„Ç¢„Éç„ÉÉ„ÇØ„É¨„ÇπÔºà„Ç∑„É´„Éê„ÉºÔºâ √ó 1 / „ÇÆ„Éï„Éà„É©„ÉÉ„Éî„É≥„Ç∞",
			SalesChannel: "„Ç™„É≥„É©„Ç§„É≥„Çπ„Éà„Ç¢",
			Integration:  "Shopify",
		}),
		makeOrder(Order{
			ID:          "order-1050",
			Number:      "1050",
			CreatedAt:   now.Add(-30 * time.Hour),
			UpdatedAt:   now.Add(-10 * time.Hour),
			Customer:    Customer{ID: "cust-7888", Name: "‰ΩêËó§ ÁúüÂ∏Ü", Email: "maho.sato@example.com"},
			TotalMinor:  1840000,
			Currency:    "JPY",
			Status:      StatusShipped,
			StatusLabel: "Áô∫ÈÄÅÊ∏à„Åø",
			Fulfillment: Fulfillment{
				Method:        "ÂÆÖÈÖç‰æø",
				Carrier:       "„É§„Éû„ÉàÈÅãËº∏",
				TrackingID:    "5543-2021-9921",
				DispatchedAt:  ptrTime(now.Add(-11 * time.Hour)),
				PromisedDate:  ptrTime(now.Add(12 * time.Hour)),
				SLAStatus:     "ÈÖçÈÄÅ‰∏≠",
				SLAStatusTone: "info",
			},
			Payment: Payment{
				Status:     "ÊîØÊâï„ÅÑÊ∏à„Åø",
				StatusTone: "success",
				CapturedAt: ptrTime(now.Add(-28 * time.Hour)),
			},
			Payments: []PaymentDetail{
				makePaymentDetail(
					"pay-1050",
					"Stripe",
					"„ÇØ„É¨„Ç∏„ÉÉ„Éà„Ç´„Éº„Éâ",
					"5210",
					"pay_1050",
					"ÊîØÊâï„ÅÑÊ∏à„Åø",
					"success",
					"JPY",
					1840000,
					1840000,
					0,
					ptrTime(now.Add(-28*time.Hour)),
				),
			},
			Tags:         []string{"Âú®Â∫´", "Ê®ôÊ∫ñ"},
			Badges:       []Badge{{Label: "Ë¶ÅÈÖçÈÄÅ„Éï„Ç©„É≠„Éº", Tone: "warning", Icon: "üì¶"}},
			ItemsSummary: "„Ç´„ÉÉ„Éó„É´„É™„É≥„Ç∞Ôºà„Ç∑„É´„Éê„ÉºÔºâ √ó 2",
			SalesChannel: "„Ç™„É≥„É©„Ç§„É≥„Çπ„Éà„Ç¢",
			Integration:  "Shopify",
		}),
		makeOrder(Order{
			ID:          "order-1049",
			Number:      "1049",
			CreatedAt:   now.Add(-72 * time.Hour),
			UpdatedAt:   now.Add(-20 * time.Hour),
			Customer:    Customer{ID: "cust-7420", Name: "ÊùæÊú¨ Êãì‰πü", Email: "takuya.matsumoto@example.com"},
			TotalMinor:  5480000,
			Currency:    "JPY",
			Status:      StatusDelivered,
			StatusLabel: "Á¥çÂìÅÊ∏à„Åø",
			Fulfillment: Fulfillment{
				Method:        "ÂÆÖÈÖç‰æø",
				Carrier:       "‰ΩêÂ∑ùÊÄ•‰æø",
				TrackingID:    "3881-9932-5520",
				DispatchedAt:  ptrTime(now.Add(-36 * time.Hour)),
				DeliveredAt:   ptrTime(now.Add(-22 * time.Hour)),
				SLAStatus:     "ÊúüÈôêÂÜÖ„ÅßÂÆå‰∫Ü",
				SLAStatusTone: "success",
			},
			Payment: Payment{
				Status:        "Ë´ãÊ±ÇÊ∏à„Åø",
				StatusTone:    "info",
				CapturedAt:    ptrTime(now.Add(-40 * time.Hour)),
				DueAt:         ptrTime(now.Add(-16 * time.Hour)),
				PastDue:       false,
				PastDueReason: "",
			},
			Payments: []PaymentDetail{
				makePaymentDetail(
					"pay-1049",
					"Stripe",
					"ÈäÄË°åÊåØËæº",
					"",
					"pay_1049",
					"Ë´ãÊ±ÇÊ∏à„Åø",
					"info",
					"JPY",
					5480000,
					5480000,
					0,
					ptrTime(now.Add(-40*time.Hour)),
				),
			},
			Tags:         []string{"„Ç´„Çπ„Çø„É†", "È´òÈ°ç"},
			Badges:       []Badge{{Label: "Âà∂‰ΩúÂÆå‰∫Ü", Tone: "success", Icon: "‚úÖ"}},
			ItemsSummary: "ÁâπÊ≥®„Ç∑„Ç∞„Éç„ÉÉ„Éà„É™„É≥„Ç∞ √ó 1 / ‰ªòÂ±û„Ç±„Éº„Çπ",
			SalesChannel: "Ê≥ï‰∫∫ÂèóÊ≥®",
			Integration:  "ÈõªË©±ÂèóÊ≥®",
		}),
		makeOrder(Order{
			ID:          "order-1048",
			Number:      "1048",
			CreatedAt:   now.Add(-26 * time.Hour),
			UpdatedAt:   now.Add(-2 * time.Hour),
			Customer:    Customer{ID: "cust-7011", Name: "Â∞èÊûó ÁæéÂí≤", Email: "misaki.kobayashi@example.com"},
			TotalMinor:  2680000,
			Currency:    "JPY",
			Status:      StatusPaymentReview,
			StatusLabel: "ÊîØÊâï„ÅÑÁ¢∫Ë™ç‰∏≠",
			Fulfillment: Fulfillment{
				Method:        "Âà∂‰ΩúÂâç",
				PromisedDate:  ptrTime(now.Add(72 * time.Hour)),
				SLAStatus:     "ÊîØÊâï„ÅÑÂæÖ„Å°",
				SLAStatusTone: "warning",
			},
			Payment: Payment{
				Status:        "ÂØ©Êüª‰∏≠",
				StatusTone:    "warning",
				DueAt:         ptrTime(now.Add(-1 * time.Hour)),
				PastDue:       true,
				PastDueReason: "„Ç™„Éï„É©„Ç§„É≥Ê±∫Ê∏àÁ¢∫Ë™çÂæÖ„Å°",
			},
			Payments: []PaymentDetail{
				makePaymentDetail(
					"pay-1048",
					"„Ç™„Éï„É©„Ç§„É≥Ê±∫Ê∏à",
					"ÈäÄË°åÊåØËæº",
					"",
					"pay_1048",
					"ÂØ©Êüª‰∏≠",
					"warning",
					"JPY",
					2680000,
					0,
					0,
					nil,
				),
			},
			Tags:             []string{"„Ç™„Éï„É©„Ç§„É≥Ê±∫Ê∏à", "Âà∂‰ΩúÂâç"},
			Badges:           []Badge{{Label: "Ë¶ÅÊîØÊâï„ÅÑ„Éï„Ç©„É≠„Éº", Tone: "danger", Icon: "‚ö†Ô∏è"}},
			ItemsSummary:     "„Ç™„Éº„ÉÄ„Éº„É°„Ç§„Éâ „Éç„ÉÉ„ÇØ„É¨„Çπ √ó 1",
			SalesChannel:     "Â∫óËàóÂèóÊ≥®",
			Integration:      "POS",
			HasRefundRequest: false,
		}),
		makeOrder(Order{
			ID:          "order-1047",
			Number:      "1047",
			CreatedAt:   now.Add(-48 * time.Hour),
			UpdatedAt:   now.Add(-5 * time.Hour),
			Customer:    Customer{ID: "cust-6892", Name: "Ilena Smith", Email: "ilena.smith@example.com"},
			TotalMinor:  4525000,
			Currency:    "USD",
			Status:      StatusShipped,
			StatusLabel: "Áô∫ÈÄÅÊ∏à„Åø",
			Fulfillment: Fulfillment{
				Method:        "ÂõΩÈöõÈÖçÈÄÅ",
				Carrier:       "FedEx",
				TrackingID:    "FEDEX-4488123",
				DispatchedAt:  ptrTime(now.Add(-18 * time.Hour)),
				SLAStatus:     "ÂõΩÈöõËº∏ÈÄÅ‰∏≠",
				SLAStatusTone: "info",
			},
			Payment: Payment{
				Status:     "ÊîØÊâï„ÅÑÊ∏à„Åø",
				StatusTone: "success",
				CapturedAt: ptrTime(now.Add(-44 * time.Hour)),
			},
			Payments: []PaymentDetail{
				makePaymentDetail(
					"pay-1047",
					"Stripe",
					"„ÇØ„É¨„Ç∏„ÉÉ„Éà„Ç´„Éº„Éâ",
					"7788",
					"pay_1047",
					"ÊîØÊâï„ÅÑÊ∏à„Åø",
					"success",
					"USD",
					4525000,
					4525000,
					625000,
					ptrTime(now.Add(-44*time.Hour)),
				),
			},
			Refunds: []RefundRecord{
				makeRefundRecord(
					"refund-1047-1",
					"pay-1047",
					625000,
					"USD",
					"„Çµ„Ç§„Ç∫ÂÜçË™øÊï¥„ÅÆÂ∑ÆÈ°çËøîÈáë",
					"succeeded",
					"support@hanko.example",
					now.Add(-12*time.Hour),
				),
			},
			Tags:             []string{"Êµ∑Â§ñ", "USD"},
			Badges:           []Badge{{Label: "ÂõΩÈöõÈÄÅÊñôË®àÁÆóÊ∏à„Åø", Tone: "info", Icon: "üåê"}},
			ItemsSummary:     "Custom Signet Ring √ó 1 / Gift Wrap",
			SalesChannel:     "Etsy",
			Integration:      "Etsy",
			HasRefundRequest: true,
		}),
		makeOrder(Order{
			ID:          "order-1046",
			Number:      "1046",
			CreatedAt:   now.Add(-6 * time.Hour),
			UpdatedAt:   now.Add(-30 * time.Minute),
			Customer:    Customer{ID: "cust-6552", Name: "Áî∞‰∏≠ ÊÑõ", Email: "ai.tanaka@example.com"},
			TotalMinor:  980000,
			Currency:    "JPY",
			Status:      StatusPendingPayment,
			StatusLabel: "ÊîØÊâï„ÅÑÂæÖ„Å°",
			Fulfillment: Fulfillment{
				Method:        "Âà∂‰ΩúÂâç",
				SLAStatus:     "ÂÖ•ÈáëÂæÖ„Å°",
				SLAStatusTone: "warning",
			},
			Payment: Payment{
				Status:        "Êú™Êâï„ÅÑ",
				StatusTone:    "warning",
				DueAt:         ptrTime(now.Add(12 * time.Hour)),
				PastDue:       false,
				PastDueReason: "",
			},
			Payments: []PaymentDetail{
				makePaymentDetail(
					"pay-1046",
					"Stripe",
					"„ÇØ„É¨„Ç∏„ÉÉ„Éà„Ç´„Éº„Éâ",
					"3005",
					"pay_1046",
					"Êú™Êâï„ÅÑ",
					"warning",
					"JPY",
					980000,
					0,
					0,
					nil,
				),
			},
			Tags:         []string{"„Ç™„É≥„É©„Ç§„É≥", "Ë¶Å„Éï„Ç©„É≠„Éº"},
			Badges:       []Badge{{Label: "SMS„É™„Éû„Ç§„É≥„Éâ‰∫àÂÆö", Tone: "info", Icon: "üì±"}},
			ItemsSummary: "„Éö„Ç¢„Éñ„É¨„Çπ„É¨„ÉÉ„Éà √ó 1",
			SalesChannel: "„Ç™„É≥„É©„Ç§„É≥„Çπ„Éà„Ç¢",
			Integration:  "Shopify",
		}),
		makeOrder(Order{
			ID:          "order-1045",
			Number:      "1045",
			CreatedAt:   now.Add(-96 * time.Hour),
			UpdatedAt:   now.Add(-6 * time.Hour),
			Customer:    Customer{ID: "cust-6021", Name: "Èà¥Êú® Ë£ï‰ªã", Email: "yusuke.suzuki@example.com"},
			TotalMinor:  3880000,
			Currency:    "JPY",
			Status:      StatusRefunded,
			StatusLabel: "ËøîÈáëÊ∏à„Åø",
			Fulfillment: Fulfillment{
				Method:        "Âà∂‰Ωú„Å™„Åó",
				SLAStatus:     "ËøîÈáëÂÆå‰∫Ü",
				SLAStatusTone: "muted",
			},
			Payment: Payment{
				Status:     "ËøîÈáëÊ∏à„Åø",
				StatusTone: "info",
				CapturedAt: ptrTime(now.Add(-90 * time.Hour)),
			},
			Payments: []PaymentDetail{
				makePaymentDetail(
					"pay-1045",
					"Stripe",
					"„ÇØ„É¨„Ç∏„ÉÉ„Éà„Ç´„Éº„Éâ",
					"9900",
					"pay_1045",
					"ËøîÈáëÊ∏à„Åø",
					"info",
					"JPY",
					3880000,
					3880000,
					3880000,
					ptrTime(now.Add(-90*time.Hour)),
				),
			},
			Refunds: []RefundRecord{
				makeRefundRecord(
					"refund-1045-1",
					"pay-1045",
					3880000,
					"JPY",
					"È°ßÂÆ¢„Ç≠„É£„É≥„Çª„É´„Å´„Çà„ÇãÂÖ®È°çËøîÈáë",
					"succeeded",
					"finance@hanko.example",
					now.Add(-6*time.Hour),
				),
			},
			Tags:             []string{"„Ç≠„É£„É≥„Çª„É´"},
			Badges:           []Badge{{Label: "ËøîÈáëÊ∏à„Åø", Tone: "info", Icon: "‚Ü©Ô∏é"}},
			ItemsSummary:     "„Ç´„Çπ„Çø„É†„Ç™„Éº„ÉÄ„Éº √ó 1",
			SalesChannel:     "Ê≥ï‰∫∫ÂèóÊ≥®",
			Integration:      "ÈõªË©±ÂèóÊ≥®",
			HasRefundRequest: true,
		}),
		makeOrder(Order{
			ID:          "order-1044",
			Number:      "1044",
			CreatedAt:   now.Add(-40 * time.Hour),
			UpdatedAt:   now.Add(-3 * time.Hour),
			Customer:    Customer{ID: "cust-5777", Name: "Êùë‰∏ä Áî±Áæé", Email: "yumi.murakami@example.com"},
			TotalMinor:  2150000,
			Currency:    "JPY",
			Status:      StatusInProduction,
			StatusLabel: "Âà∂‰Ωú‰∏≠",
			Fulfillment: Fulfillment{
				Method:        "ÂàªÂç∞Â∑•Êàø",
				PromisedDate:  ptrTime(now.Add(-1 * time.Hour)),
				SLAStatus:     "SLAÈÅÖÂª∂ 5ÊôÇÈñì",
				SLAStatusTone: "danger",
			},
			Payment: Payment{
				Status:     "ÊîØÊâï„ÅÑÊ∏à„Åø",
				StatusTone: "success",
				CapturedAt: ptrTime(now.Add(-39 * time.Hour)),
			},
			Payments: []PaymentDetail{
				makePaymentDetail(
					"pay-1044",
					"Stripe",
					"„ÇØ„É¨„Ç∏„ÉÉ„Éà„Ç´„Éº„Éâ",
					"5561",
					"pay_1044",
					"ÊîØÊâï„ÅÑÊ∏à„Åø",
					"success",
					"JPY",
					2150000,
					2150000,
					500000,
					ptrTime(now.Add(-39*time.Hour)),
				),
			},
			Refunds: []RefundRecord{
				makeRefundRecord(
					"refund-1044-1",
					"pay-1044",
					500000,
					"JPY",
					"SLAÈÅÖÂª∂„Å´„Çà„ÇãË£úÂÑü",
					"processing",
					"support@hanko.example",
					now.Add(-2*time.Hour),
				),
			},
			Tags:             []string{"Ë¶Å„Éï„Ç©„É≠„Éº", "ËøîÈáëÁî≥Ë´ã"},
			Badges:           []Badge{{Label: "Ë¶ÅÂÑ™ÂÖàÂØæÂøú", Tone: "danger", Icon: "üö©"}},
			ItemsSummary:     "„Éö„É≥„ÉÄ„É≥„Éà„Éà„ÉÉ„ÉóÔºà„Ç¥„Éº„É´„ÉâÔºâ √ó 1",
			Notes:            []string{"È°ßÂÆ¢„ÅåSLAÈÅÖÂª∂„Å´Èñ¢„Åô„ÇãÈÄ£Áµ°Ê∏à„Åø"},
			SalesChannel:     "„Ç™„É≥„É©„Ç§„É≥„Çπ„Éà„Ç¢",
			Integration:      "Shopify",
			HasRefundRequest: true,
		}),
		makeOrder(Order{
			ID:          "order-1043",
			Number:      "1043",
			CreatedAt:   now.Add(-18 * time.Hour),
			UpdatedAt:   now.Add(-90 * time.Minute),
			Customer:    Customer{ID: "cust-5524", Name: "Carlos Diaz", Email: "carlos.diaz@example.com"},
			TotalMinor:  2755000,
			Currency:    "USD",
			Status:      StatusReadyToShip,
			StatusLabel: "Âá∫Ëç∑ÂæÖ„Å°",
			Fulfillment: Fulfillment{
				Method:        "ÂõΩÈöõÈÖçÈÄÅ",
				Carrier:       "UPS",
				PromisedDate:  ptrTime(now.Add(24 * time.Hour)),
				SLAStatus:     "Ëº∏Âá∫Êõ∏È°ûÁ¢∫Ë™ç‰∏≠",
				SLAStatusTone: "info",
			},
			Payment: Payment{
				Status:     "ÊîØÊâï„ÅÑÊ∏à„Åø",
				StatusTone: "success",
				CapturedAt: ptrTime(now.Add(-16 * time.Hour)),
			},
			Payments: []PaymentDetail{
				makePaymentDetail(
					"pay-1043",
					"Stripe",
					"„ÇØ„É¨„Ç∏„ÉÉ„Éà„Ç´„Éº„Éâ",
					"4431",
					"pay_1043",
					"ÊîØÊâï„ÅÑÊ∏à„Åø",
					"success",
					"USD",
					2755000,
					2755000,
					0,
					ptrTime(now.Add(-16*time.Hour)),
				),
			},
			Tags:         []string{"Êµ∑Â§ñ", "Ê≥ï‰∫∫"},
			Badges:       []Badge{{Label: "ÂïÜÁî®„Ç§„É≥„Éú„Ç§„ÇπÂøÖË¶Å", Tone: "warning", Icon: "üìÑ"}},
			ItemsSummary: "Corporate Bulk Order √ó 5",
			SalesChannel: "Wholesale",
			Integration:  "NetSuite",
		}),
		makeOrder(Order{
			ID:          "order-1042",
			Number:      "1042",
			CreatedAt:   now.Add(-7 * 24 * time.Hour),
			UpdatedAt:   now.Add(-3 * 24 * time.Hour),
			Customer:    Customer{ID: "cust-5332", Name: "Â±±Áî∞ Áõ¥Â≠ê", Email: "naoko.yamada@example.com"},
			TotalMinor:  1350000,
			Currency:    "JPY",
			Status:      StatusCancelled,
			StatusLabel: "„Ç≠„É£„É≥„Çª„É´",
			Fulfillment: Fulfillment{
				Method:        "Âà∂‰ΩúÂâç",
				SLAStatus:     "„Ç≠„É£„É≥„Çª„É´Ê∏à„Åø",
				SLAStatusTone: "muted",
			},
			Payment: Payment{
				Status:     "Êú™Ë´ãÊ±Ç",
				StatusTone: "muted",
			},
			Payments: []PaymentDetail{
				makePaymentDetail(
					"pay-1042",
					"Stripe",
					"„ÇØ„É¨„Ç∏„ÉÉ„Éà„Ç´„Éº„Éâ",
					"2210",
					"pay_1042",
					"Êú™Ë´ãÊ±Ç",
					"muted",
					"JPY",
					1350000,
					0,
					0,
					nil,
				),
			},
			Tags:         []string{"È°ßÂÆ¢ÈÉΩÂêà"},
			Badges:       []Badge{{Label: "„Ç≠„É£„É≥„Çª„É´", Tone: "muted", Icon: "‚úï"}},
			ItemsSummary: "ÂêçÂÖ•„Çå„Ç≠„Éº„Éõ„É´„ÉÄ„Éº √ó 2",
			SalesChannel: "„Ç™„É≥„É©„Ç§„É≥„Çπ„Éà„Ç¢",
			Integration:  "Shopify",
		}),
		makeOrder(Order{
			ID:          "order-1041",
			Number:      "1041",
			CreatedAt:   now.Add(-5 * 24 * time.Hour),
			UpdatedAt:   now.Add(-18 * time.Hour),
			Customer:    Customer{ID: "cust-5200", Name: "„Ç®„Éü„É™„Éº Áéã", Email: "emily.wang@example.com"},
			TotalMinor:  2980000,
			Currency:    "JPY",
			Status:      StatusDelivered,
			StatusLabel: "Á¥çÂìÅÊ∏à„Åø",
			Fulfillment: Fulfillment{
				Method:        "ÂÆÖÈÖç‰æø",
				Carrier:       "„É§„Éû„ÉàÈÅãËº∏",
				TrackingID:    "1182-5521-9982",
				DispatchedAt:  ptrTime(now.Add(-42 * time.Hour)),
				DeliveredAt:   ptrTime(now.Add(-20 * time.Hour)),
				SLAStatus:     "Êó©ÊúüÈÖçÈÅî",
				SLAStatusTone: "success",
			},
			Payment: Payment{
				Status:     "ÊîØÊâï„ÅÑÊ∏à„Åø",
				StatusTone: "success",
				CapturedAt: ptrTime(now.Add(-4 * 24 * time.Hour)),
			},
			Payments: []PaymentDetail{
				makePaymentDetail(
					"pay-1041",
					"Stripe",
					"„ÇØ„É¨„Ç∏„ÉÉ„Éà„Ç´„Éº„Éâ",
					"6622",
					"pay_1041",
					"ÊîØÊâï„ÅÑÊ∏à„Åø",
					"success",
					"JPY",
					2980000,
					2980000,
					0,
					ptrTime(now.Add(-4*24*time.Hour)),
				),
			},
			Tags:         []string{"Âú®Â∫´", "ÈÄöÂ∏∏"},
			Badges:       []Badge{{Label: "„É¨„Éì„É•„Éº‰æùÈ†ºÊ∏à„Åø", Tone: "info", Icon: "‚≠ê"}},
			ItemsSummary: "„Çπ„Çø„Éº„É™„É≥„Ç∞„Ç∑„É´„Éê„Éº„É™„É≥„Ç∞ √ó 1 / „Çµ„Ç§„Ç∫Ë™øÊï¥",
			SalesChannel: "„Ç™„É≥„É©„Ç§„É≥„Çπ„Éà„Ç¢",
			Integration:  "Shopify",
		}),
	}

	for i := range orders {
		switch orders[i].ID {
		case "order-1052":
			orders[i].Invoices = []InvoiceRecord{
				{
					ID:            "inv-order-1052-001",
					Number:        "INV-2025-001",
					Status:        "Áô∫Ë°åÊ∏à„Åø",
					StatusTone:    "success",
					IssuedAt:      now.Add(-6 * time.Hour),
					DeliveryEmail: "jun.hasegawa@example.com",
					Note:          "Âà∂‰ΩúÈñãÂßãÊôÇ„Å´ÈÄÅ‰ªò",
					Actor:         "finance@hanko.example",
					PDFURL:        "https://storage.example.com/invoices/INV-2025-001.pdf",
					TemplateID:    "invoice-standard",
					Language:      "ja-JP",
					CreatedAt:     now.Add(-6 * time.Hour),
					UpdatedAt:     now.Add(-6 * time.Hour),
				},
			}
		case "order-1050":
			orders[i].Invoices = []InvoiceRecord{
				{
					ID:            "inv-order-1050-001",
					Number:        "INV-2025-045",
					Status:        "Áô∫Ë°åÊ∫ñÂÇô‰∏≠",
					StatusTone:    "info",
					DeliveryEmail: "maho.sato@example.com",
					Note:          "Ê≥ï‰∫∫Ë´ãÊ±ÇÊõ∏ („Éê„ÉÉ„ÉÅ)",
					Actor:         "ops@hanko.example",
					TemplateID:    "invoice-batch",
					Language:      "ja-JP",
					JobID:         "job-invoice-1050-1",
					CreatedAt:     now.Add(-10 * time.Minute),
					UpdatedAt:     now.Add(-10 * time.Minute),
				},
			}
		case "order-1047":
			orders[i].Invoices = []InvoiceRecord{
				{
					ID:            "inv-order-1047-001",
					Number:        "INV-2025-019",
					Status:        "Áô∫Ë°åÊ∏à„Åø",
					StatusTone:    "success",
					IssuedAt:      now.Add(-12 * time.Hour),
					DeliveryEmail: "ilena.smith@example.com",
					Note:          "International shipment invoice",
					Actor:         "finance@hanko.example",
					PDFURL:        "https://storage.example.com/invoices/INV-2025-019.pdf",
					TemplateID:    "invoice-standard",
					Language:      "en-US",
					CreatedAt:     now.Add(-12 * time.Hour),
					UpdatedAt:     now.Add(-12 * time.Hour),
				},
			}
		case "order-1045":
			orders[i].Invoices = []InvoiceRecord{
				{
					ID:            "inv-order-1045-001",
					Number:        "INV-2024-312",
					Status:        "„Ç≠„É£„É≥„Çª„É´Ê∏à„Åø",
					StatusTone:    "muted",
					IssuedAt:      now.Add(-80 * time.Hour),
					DeliveryEmail: "yusuke.suzuki@example.com",
					Note:          "ËøîÈáëÂØæÂøú„ÅÆ„Åü„ÇÅÁÑ°ÂäπÂåñÊ∏à„Åø",
					Actor:         "finance@hanko.example",
					PDFURL:        "",
					TemplateID:    "invoice-detailed",
					Language:      "ja-JP",
					CreatedAt:     now.Add(-81 * time.Hour),
					UpdatedAt:     now.Add(-80 * time.Hour),
				},
			}
		}
	}

	templates := []InvoiceTemplate{
		{
			ID:          "invoice-standard",
			Label:       "Ê®ôÊ∫ñ„ÉÜ„É≥„Éó„É¨„Éº„ÉàÔºàÊó•Êú¨Ë™ûÔºâ",
			Description: "‰∏ÄËà¨ÁöÑ„Å™ÂÄã‰∫∫Âêë„Åë„Éï„Ç©„Éº„Éû„ÉÉ„Éà„ÄÇÁ®éËæºË°®Á§∫„Å®Ê≥®ÊñáÁï™Âè∑„ÇíÂê´„Åø„Åæ„Åô„ÄÇ",
			Default:     true,
		},
		{
			ID:          "invoice-detailed",
			Label:       "ÊòéÁ¥∞‰ªò„Åç„ÉÜ„É≥„Éó„É¨„Éº„Éà",
			Description: "„É©„Ç§„É≥„Ç¢„Ç§„ÉÜ„É†„Å®ÂÇôËÄÉ„ÇíÁ¥∞„Åã„ÅèË®òËºâ„Åó„Åæ„Åô„ÄÇ",
			Default:     false,
		},
		{
			ID:          "invoice-batch",
			Label:       "Ê≥ï‰∫∫Ë´ãÊ±ÇÔºà„Éê„ÉÉ„ÉÅÁîüÊàêÔºâ",
			Description: "Â§ßÈáèÁô∫Ë°åÂêë„Åë„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÄÇÁîüÊàê„Å´Êï∞ÂàÜ„Åã„Åã„ÇãÂ†¥Âêà„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ",
			Default:     false,
		},
	}

	languages := []InvoiceLanguage{
		{Code: "ja-JP", Label: "Êó•Êú¨Ë™û", Default: true},
		{Code: "en-US", Label: "English", Default: false},
	}

	invoiceJobs := make(map[string]*invoiceJobState)
	for _, order := range orders {
		for _, invoice := range order.Invoices {
			jobID := strings.TrimSpace(invoice.JobID)
			if jobID == "" {
				continue
			}
			state := &invoiceJobState{
				OrderID:   order.ID,
				InvoiceID: invoice.ID,
				Job: InvoiceJob{
					ID:          jobID,
					Status:      "„Ç≠„É•„ÉºÊäïÂÖ•Ê∏à„Åø",
					StatusTone:  "info",
					SubmittedAt: invoice.CreatedAt,
					Message:     "„Éê„ÉÉ„ÉÅÂá¶ÁêÜ„ÅßPDF„ÇíÁîüÊàê‰∏≠„Åß„ÅôÔºàÈÄöÂ∏∏1-2ÂàÜÁ®ãÂ∫¶Ôºâ„ÄÇ",
				},
				Completed: false,
			}
			invoiceJobs[jobID] = state
		}
	}

	timelines := make(map[string][]TimelineEvent, len(orders))
	for _, order := range orders {
		timelines[order.ID] = seedTimeline(order)
	}

	exportJobs := make(map[string]*exportJobState)

	return &StaticService{
		orders:           orders,
		timelines:        timelines,
		invoiceJobs:      invoiceJobs,
		exportJobs:       exportJobs,
		invoiceTemplates: templates,
		invoiceLanguages: languages,
		audit:            noopAuditLogger{},
	}
}

var exportAllowedFields = map[ExportFormat][]string{
	ExportFormatCSV: {
		"order_id",
		"order_number",
		"status",
		"total_minor",
		"currency",
		"customer_name",
		"created_at",
	},
	ExportFormatPDF: {
		"order_number",
		"customer_name",
		"items",
		"total_minor",
		"currency",
		"fulfillment",
	},
}

func (s *StaticService) snapshotOrders() []Order {
	s.mu.RLock()
	defer s.mu.RUnlock()
	copy := make([]Order, len(s.orders))
	for i, order := range s.orders {
		copy[i] = cloneOrder(order)
	}
	return copy
}

func cloneOrder(order Order) Order {
	result := order
	if len(order.Tags) > 0 {
		result.Tags = append([]string(nil), order.Tags...)
	}
	if len(order.Badges) > 0 {
		result.Badges = append([]Badge(nil), order.Badges...)
	}
	if len(order.Notes) > 0 {
		result.Notes = append([]string(nil), order.Notes...)
	}
	if len(order.Payments) > 0 {
		result.Payments = append([]PaymentDetail(nil), order.Payments...)
	}
	if len(order.Refunds) > 0 {
		result.Refunds = append([]RefundRecord(nil), order.Refunds...)
	}
	if len(order.Invoices) > 0 {
		result.Invoices = append([]InvoiceRecord(nil), order.Invoices...)
	}
	return result
}

func cloneTimeline(events []TimelineEvent) []TimelineEvent {
	if len(events) == 0 {
		return nil
	}
	cloned := make([]TimelineEvent, len(events))
	copy(cloned, events)
	return cloned
}

func cloneExportJob(job ExportJob) ExportJob {
	copied := job
	if job.CompletedAt != nil {
		ts := *job.CompletedAt
		copied.CompletedAt = &ts
	}
	if len(job.Fields) > 0 {
		copied.Fields = append([]string(nil), job.Fields...)
	}
	return copied
}

func normaliseExportFormat(format ExportFormat) ExportFormat {
	switch strings.ToLower(strings.TrimSpace(string(format))) {
	case string(ExportFormatPDF):
		return ExportFormatPDF
	default:
		return ExportFormatCSV
	}
}

func exportQueuedMessage(format ExportFormat) string {
	switch format {
	case ExportFormatPDF:
		return "Âç∞Âà∑Áî®PDF„ÇíÁîüÊàê„Ç≠„É•„Éº„Å´ÊäïÂÖ•„Åó„Åæ„Åó„Åü„ÄÇÊ∫ñÂÇô„Åå„Åß„ÅçÊ¨°Á¨¨„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åß„Åç„Åæ„Åô„ÄÇ"
	default:
		return "CSV„Ç®„ÇØ„Çπ„Éù„Éº„Éà„ÇíÊ∫ñÂÇô„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂÆå‰∫ÜÂæå„Å´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„É™„É≥„ÇØ„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ"
	}
}

func exportProcessingMessage(format ExportFormat) string {
	switch format {
	case ExportFormatPDF:
		return "PDF„ÇíÁîüÊàê„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂÆå‰∫Ü„Åæ„Åß„Åó„Å∞„Çâ„Åè„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ"
	default:
		return "CSV„ÇíÊõ∏„ÅçÂá∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂÆå‰∫Ü„Åæ„Åß„Åó„Å∞„Çâ„Åè„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ"
	}
}

func exportCompletedMessage(format ExportFormat) string {
	switch format {
	case ExportFormatPDF:
		return "PDF„ÅÆÁîüÊàê„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„É™„É≥„ÇØ„Åã„ÇâÂç∞Âà∑„Åß„Åç„Åæ„Åô„ÄÇ"
	default:
		return "CSV„Ç®„ÇØ„Çπ„Éù„Éº„Éà„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„É™„É≥„ÇØ„Åã„ÇâÂèñÂæó„Åß„Åç„Åæ„Åô„ÄÇ"
	}
}

func buildExportDownloadURL(format ExportFormat, jobID string) string {
	safeID := strings.TrimSpace(jobID)
	if safeID == "" {
		return ""
	}
	safeID = strings.ReplaceAll(safeID, " ", "_")
	switch format {
	case ExportFormatPDF:
		return fmt.Sprintf("https://storage.example.com/orders/exports/%s.pdf", safeID)
	default:
		return fmt.Sprintf("https://storage.example.com/orders/exports/%s.csv", safeID)
	}
}

// List implements the orders Service interface.
func (s *StaticService) List(_ context.Context, _ string, query Query) (ListResult, error) {
	orders := s.snapshotOrders()
	withStatus := filterOrders(orders, query, true)

	sortOrders(withStatus, query)

	total := len(withStatus)
	pageSize := query.PageSize
	if pageSize <= 0 {
		pageSize = 20
	}
	page := query.Page
	if page <= 0 {
		page = 1
	}

	start := (page - 1) * pageSize
	if start > total {
		start = total
	}
	end := start + pageSize
	if end > total {
		end = total
	}

	pageOrders := append([]Order(nil), withStatus[start:end]...)

	pagination := Pagination{
		Page:       page,
		PageSize:   pageSize,
		TotalItems: total,
	}
	if end < total {
		next := page + 1
		pagination.NextPage = &next
	}
	if page > 1 && start <= total {
		prev := page - 1
		if prev >= 1 {
			pagination.PrevPage = &prev
		}
	}

	summary := buildSummary(withStatus)

	filters := buildFilterSummary(orders, query)

	return ListResult{
		Orders:     pageOrders,
		Pagination: pagination,
		Summary:    summary,
		Filters:    filters,
	}, nil
}

// StatusModal assembles modal data for the specified order.
func (s *StaticService) StatusModal(_ context.Context, _ string, orderID string) (StatusModal, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	_, order := s.findOrderLocked(orderID)
	if order == nil {
		return StatusModal{}, ErrOrderNotFound
	}

	orderCopy := cloneOrder(*order)
	choices := buildStatusChoices(orderCopy.Status)
	events := cloneTimeline(s.timelines[orderID])
	if len(events) > 5 {
		events = events[len(events)-5:]
	}

	return StatusModal{
		Order:          orderCopy,
		Choices:        choices,
		LatestTimeline: events,
	}, nil
}

// RefundModal assembles refund modal data for the specified order.
func (s *StaticService) RefundModal(_ context.Context, _ string, orderID string) (RefundModal, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	_, order := s.findOrderLocked(orderID)
	if order == nil {
		return RefundModal{}, ErrOrderNotFound
	}

	cloned := cloneOrder(*order)

	options := make([]RefundPaymentOption, 0, len(cloned.Payments))
	for _, payment := range cloned.Payments {
		options = append(options, toRefundPaymentOption(payment))
	}

	supportsPartial := false
	for _, option := range options {
		if option.AvailableMinor > 0 {
			supportsPartial = true
			break
		}
	}

	existing := append([]RefundRecord(nil), cloned.Refunds...)

	outstanding := ""
	if cloned.Payment.PastDue {
		outstanding = strings.TrimSpace(cloned.Payment.PastDueReason)
		if outstanding == "" {
			outstanding = "ÊîØÊâï„ÅÑÁ¢∫Ë™ç‰∏≠"
		}
	}

	summary := RefundOrderSummary{
		ID:             cloned.ID,
		Number:         cloned.Number,
		CustomerName:   cloned.Customer.Name,
		TotalMinor:     cloned.TotalMinor,
		Currency:       cloned.Currency,
		PaymentStatus:  cloned.Payment.Status,
		PaymentTone:    cloned.Payment.StatusTone,
		OutstandingDue: outstanding,
	}

	return RefundModal{
		Order:           summary,
		Payments:        options,
		ExistingRefunds: existing,
		SupportsPartial: supportsPartial,
		Currency:        cloned.Currency,
	}, nil
}

// InvoiceModal assembles invoice modal data for the specified order.
func (s *StaticService) InvoiceModal(_ context.Context, _ string, orderID string) (InvoiceModal, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	_, order := s.findOrderLocked(orderID)
	if order == nil {
		return InvoiceModal{}, ErrOrderNotFound
	}

	cloned := cloneOrder(*order)

	recent := append([]InvoiceRecord(nil), cloned.Invoices...)
	sort.SliceStable(recent, func(i, j int) bool {
		return recent[i].UpdatedAt.After(recent[j].UpdatedAt)
	})

	templates := append([]InvoiceTemplate(nil), s.invoiceTemplates...)
	languages := append([]InvoiceLanguage(nil), s.invoiceLanguages...)

	defaultTemplate := defaultInvoiceTemplateID(templates)
	defaultLanguage := defaultInvoiceLanguageCode(languages)

	summary := InvoiceOrderSummary{
		ID:            cloned.ID,
		Number:        cloned.Number,
		CustomerName:  cloned.Customer.Name,
		CustomerEmail: cloned.Customer.Email,
		Currency:      cloned.Currency,
		TotalMinor:    cloned.TotalMinor,
	}

	return InvoiceModal{
		Order:           summary,
		Templates:       templates,
		Languages:       languages,
		SuggestedEmail:  strings.TrimSpace(cloned.Customer.Email),
		RecentInvoices:  recent,
		DefaultTemplate: defaultTemplate,
		DefaultLanguage: defaultLanguage,
	}, nil
}

// IssueInvoice records a simulated invoice issuance for development usage.
func (s *StaticService) IssueInvoice(_ context.Context, _ string, req InvoiceIssueRequest) (InvoiceIssueResult, error) {
	orderID := strings.TrimSpace(req.OrderID)
	templateID := strings.TrimSpace(req.TemplateID)
	email := strings.TrimSpace(req.DeliveryEmail)
	language := strings.TrimSpace(req.Language)
	note := strings.TrimSpace(req.Note)

	fieldErrors := map[string]string{}
	if orderID == "" {
		fieldErrors["orderID"] = "Ê≥®ÊñáID„Åå‰∏çÊ≠£„Åß„Åô„ÄÇ"
	}
	if templateID == "" {
		fieldErrors["templateID"] = "„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
	}
	if email == "" {
		fieldErrors["email"] = "ÈÄÅ‰ªòÂÖà„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
	} else if !isValidEmail(email) {
		fieldErrors["email"] = "„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ„ÅÆÂΩ¢Âºè„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ"
	}

	if len(fieldErrors) > 0 {
		return InvoiceIssueResult{}, &InvoiceValidationError{
			Message:     "ÂÖ•ÂäõÂÜÖÂÆπ„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
			FieldErrors: fieldErrors,
		}
	}

	s.mu.Lock()
	defer s.mu.Unlock()

	idx, order := s.findOrderLocked(orderID)
	if order == nil {
		return InvoiceIssueResult{}, ErrOrderNotFound
	}

	template, ok := s.templateByIDLocked(templateID)
	if !ok {
		return InvoiceIssueResult{}, &InvoiceValidationError{
			Message:     "ÈÅ∏Êäû„Åó„Åü„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ",
			FieldErrors: map[string]string{"templateID": "ÈÅ∏Êäû„Åó„Åü„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ"},
		}
	}

	language = s.normaliseLanguageLocked(language)

	now := time.Now()
	counter := len(order.Invoices) + 1
	invoiceID := fmt.Sprintf("inv-%s-%d", orderID, now.UnixNano())
	invoiceNumber := fmt.Sprintf("INV-%d%02d-%03d", now.Year(), int(now.Month()), counter)
	actor := strings.TrimSpace(req.ActorEmail)
	if actor == "" {
		actor = strings.TrimSpace(req.ActorID)
	}
	if actor == "" {
		actor = "„Ç™„Éö„É¨„Éº„Çø„Éº"
	}

	invoice := InvoiceRecord{
		ID:            invoiceID,
		Number:        invoiceNumber,
		Status:        "Áô∫Ë°åÊ∏à„Åø",
		StatusTone:    "success",
		IssuedAt:      now,
		DeliveryEmail: email,
		Note:          note,
		Actor:         actor,
		PDFURL:        buildInvoicePDFURL(invoiceNumber),
		TemplateID:    template.ID,
		Language:      language,
		CreatedAt:     now,
		UpdatedAt:     now,
	}

	var job *InvoiceJob
	if strings.EqualFold(template.ID, "invoice-batch") {
		jobID := fmt.Sprintf("job-%s-%d", orderID, now.UnixNano())
		job = &InvoiceJob{
			ID:          jobID,
			Status:      "„Ç≠„É•„ÉºÊäïÂÖ•Ê∏à„Åø",
			StatusTone:  "info",
			SubmittedAt: now,
			Message:     "Ë´ãÊ±ÇÊõ∏„ÇíÁîüÊàê„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂÆå‰∫Ü„Åæ„ÅßÂ∞ë„ÅóÊôÇÈñì„Åå„Åã„Åã„ÇãÂ†¥Âêà„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ",
		}
		invoice.Status = "Áô∫Ë°åÊ∫ñÂÇô‰∏≠"
		invoice.StatusTone = "info"
		invoice.IssuedAt = time.Time{}
		invoice.PDFURL = ""
		invoice.JobID = jobID
	}

	order.Invoices = append([]InvoiceRecord{invoice}, order.Invoices...)
	s.orders[idx] = *order

	storedInvoice := order.Invoices[0]

	if job != nil {
		s.invoiceJobs[job.ID] = &invoiceJobState{
			OrderID:   orderID,
			InvoiceID: storedInvoice.ID,
			Job:       *job,
			Completed: false,
			Attempts:  0,
		}
	}

	return InvoiceIssueResult{
		OrderID: orderID,
		Invoice: storedInvoice,
		Job:     job,
	}, nil
}

// InvoiceJobStatus returns the latest status for an asynchronous invoice issuance job.
func (s *StaticService) InvoiceJobStatus(_ context.Context, _ string, jobID string) (InvoiceJobStatus, error) {
	jobID = strings.TrimSpace(jobID)
	if jobID == "" {
		return InvoiceJobStatus{}, ErrInvoiceJobNotFound
	}

	s.mu.Lock()
	defer s.mu.Unlock()

	state, ok := s.invoiceJobs[jobID]
	if !ok {
		return InvoiceJobStatus{}, ErrInvoiceJobNotFound
	}

	idx, order := s.findOrderLocked(state.OrderID)
	if order == nil {
		delete(s.invoiceJobs, jobID)
		return InvoiceJobStatus{}, ErrOrderNotFound
	}

	var invoice *InvoiceRecord
	for i := range order.Invoices {
		if order.Invoices[i].ID == state.InvoiceID {
			invoice = &order.Invoices[i]
			break
		}
	}
	if invoice == nil {
		delete(s.invoiceJobs, jobID)
		return InvoiceJobStatus{}, ErrInvoiceJobNotFound
	}

	if !state.Completed {
		state.Attempts++
		if state.Attempts >= 2 {
			state.Completed = true
			state.Job.Status = "Áô∫Ë°åÊ∏à„Åø"
			state.Job.StatusTone = "success"
			state.Job.Message = "Ë´ãÊ±ÇÊõ∏„ÅÆÁîüÊàê„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ"
			now := time.Now()
			if invoice.IssuedAt.IsZero() {
				invoice.IssuedAt = now
			}
			invoice.Status = "Áô∫Ë°åÊ∏à„Åø"
			invoice.StatusTone = "success"
			invoice.PDFURL = buildInvoicePDFURL(invoice.Number)
			invoice.JobID = ""
			invoice.UpdatedAt = now
			s.orders[idx] = *order
			delete(s.invoiceJobs, jobID)
		} else {
			state.Job.Status = "Âá¶ÁêÜ‰∏≠"
			state.Job.StatusTone = "info"
			state.Job.Message = "PDF„ÇíÁîüÊàê„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂÆå‰∫Ü„Åæ„Åß„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ"
		}
	}

	result := InvoiceJobStatus{
		OrderID: state.OrderID,
		Invoice: *invoice,
		Job:     state.Job,
		Done:    state.Completed,
	}

	if !state.Completed {
		s.invoiceJobs[jobID] = state
	}

	return result, nil
}

// StartBulkExport records a simulated export job for development usage.
func (s *StaticService) StartBulkExport(_ context.Context, _ string, req BulkExportRequest) (ExportJob, error) {
	format := normaliseExportFormat(req.Format)

	fields, ok := exportAllowedFields[format]
	if !ok {
		return ExportJob{}, ErrExportFormatNotAllowed
	}

	targetIDs := make(map[string]struct{})
	for _, raw := range req.OrderIDs {
		if trimmed := strings.TrimSpace(raw); trimmed != "" {
			targetIDs[trimmed] = struct{}{}
		}
	}

	s.mu.Lock()
	defer s.mu.Unlock()

	orders := make([]Order, len(s.orders))
	copy(orders, s.orders)

	filtered := filterOrders(orders, req.Query, true)
	if len(targetIDs) > 0 {
		subset := make([]Order, 0, len(filtered))
		for _, order := range filtered {
			if _, ok := targetIDs[order.ID]; ok {
				subset = append(subset, order)
			}
		}
		filtered = subset
	}

	total := len(filtered)
	if total == 0 {
		return ExportJob{}, ErrExportNoOrders
	}

	now := time.Now()
	jobID := fmt.Sprintf("export-%d", now.UnixNano())

	job := ExportJob{
		ID:              jobID,
		Format:          format,
		Status:          "„Ç≠„É•„ÉºÊäïÂÖ•Ê∏à„Åø",
		StatusTone:      "info",
		Message:         exportQueuedMessage(format),
		SubmittedAt:     now,
		Progress:        0,
		ProcessedOrders: 0,
		TotalOrders:     total,
		Fields:          append([]string(nil), fields...),
	}

	state := &exportJobState{
		Job:       job,
		Completed: false,
		Attempts:  0,
	}

	if s.exportJobs == nil {
		s.exportJobs = make(map[string]*exportJobState)
	}
	s.exportJobs[jobID] = state

	return cloneExportJob(job), nil
}

// ListExportJobs returns the set of known export jobs.
func (s *StaticService) ListExportJobs(_ context.Context, _ string) ([]ExportJob, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	if len(s.exportJobs) == 0 {
		return nil, nil
	}

	jobs := make([]ExportJob, 0, len(s.exportJobs))
	for _, state := range s.exportJobs {
		jobs = append(jobs, cloneExportJob(state.Job))
	}

	sort.SliceStable(jobs, func(i, j int) bool {
		return jobs[i].SubmittedAt.After(jobs[j].SubmittedAt)
	})

	return jobs, nil
}

// ExportJobStatus reports the simulated progress of an export job.
func (s *StaticService) ExportJobStatus(_ context.Context, _ string, jobID string) (ExportJobStatus, error) {
	jobID = strings.TrimSpace(jobID)
	if jobID == "" {
		return ExportJobStatus{}, ErrExportJobNotFound
	}

	s.mu.Lock()
	defer s.mu.Unlock()

	state, ok := s.exportJobs[jobID]
	if !ok {
		return ExportJobStatus{}, ErrExportJobNotFound
	}

	if !state.Completed {
		state.Attempts++

		total := state.Job.TotalOrders
		step := total / 3
		if step < 1 {
			step = 1
		}
		state.Job.ProcessedOrders += step
		if state.Job.ProcessedOrders > total {
			state.Job.ProcessedOrders = total
		}

		if total > 0 {
			state.Job.Progress = (state.Job.ProcessedOrders * 100) / total
		} else {
			state.Job.Progress = 100
		}
		if state.Job.Progress > 100 {
			state.Job.Progress = 100
		}

		if state.Attempts >= 3 || state.Job.ProcessedOrders >= total {
			now := time.Now()
			state.Completed = true
			state.Job.Status = "ÂÆå‰∫Ü"
			state.Job.StatusTone = "success"
			state.Job.Message = exportCompletedMessage(state.Job.Format)
			state.Job.ProcessedOrders = total
			state.Job.Progress = 100
			state.Job.CompletedAt = &now
			state.Job.DownloadURL = buildExportDownloadURL(state.Job.Format, jobID)
		} else {
			state.Job.Status = "Âá¶ÁêÜ‰∏≠"
			state.Job.StatusTone = "info"
			state.Job.Message = exportProcessingMessage(state.Job.Format)
		}
	}

	result := ExportJobStatus{
		Job:  cloneExportJob(state.Job),
		Done: state.Completed,
	}

	s.exportJobs[jobID] = state

	return result, nil
}

func defaultInvoiceTemplateID(templates []InvoiceTemplate) string {
	for _, tpl := range templates {
		if tpl.Default && strings.TrimSpace(tpl.ID) != "" {
			return strings.TrimSpace(tpl.ID)
		}
	}
	if len(templates) > 0 {
		return strings.TrimSpace(templates[0].ID)
	}
	return ""
}

func defaultInvoiceLanguageCode(languages []InvoiceLanguage) string {
	for _, lang := range languages {
		if lang.Default && strings.TrimSpace(lang.Code) != "" {
			return strings.TrimSpace(lang.Code)
		}
	}
	if len(languages) > 0 {
		return strings.TrimSpace(languages[0].Code)
	}
	return ""
}

func (s *StaticService) templateByIDLocked(id string) (InvoiceTemplate, bool) {
	target := strings.TrimSpace(id)
	for _, tpl := range s.invoiceTemplates {
		if strings.EqualFold(strings.TrimSpace(tpl.ID), target) {
			return tpl, true
		}
	}
	return InvoiceTemplate{}, false
}

func (s *StaticService) normaliseLanguageLocked(code string) string {
	trimmed := strings.TrimSpace(code)
	if trimmed == "" {
		return defaultInvoiceLanguageCode(s.invoiceLanguages)
	}
	for _, lang := range s.invoiceLanguages {
		if strings.EqualFold(strings.TrimSpace(lang.Code), trimmed) {
			return strings.TrimSpace(lang.Code)
		}
	}
	return defaultInvoiceLanguageCode(s.invoiceLanguages)
}

func isValidEmail(value string) bool {
	value = strings.TrimSpace(value)
	if value == "" {
		return false
	}
	if _, err := mail.ParseAddress(value); err != nil {
		return false
	}
	return true
}

func buildInvoicePDFURL(number string) string {
	safe := strings.TrimSpace(number)
	if safe == "" {
		return ""
	}
	safe = strings.ReplaceAll(safe, " ", "_")
	return fmt.Sprintf("https://storage.example.com/invoices/%s.pdf", safe)
}

// UpdateStatus mutates the order status with optimistic local data for development use.
func (s *StaticService) UpdateStatus(ctx context.Context, _ string, orderID string, req StatusUpdateRequest) (StatusUpdateResult, error) {
	requested := strings.TrimSpace(string(req.Status))
	if requested == "" {
		return StatusUpdateResult{}, &StatusTransitionError{From: Status(""), To: req.Status, Reason: "„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ"}
	}

	s.mu.Lock()
	defer s.mu.Unlock()

	idx, order := s.findOrderLocked(orderID)
	if order == nil {
		return StatusUpdateResult{}, ErrOrderNotFound
	}

	current := order.Status
	if current == req.Status {
		return StatusUpdateResult{}, &StatusTransitionError{From: current, To: req.Status, Reason: "„Åô„Åß„Å´„Åì„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„Åß„Åô"}
	}
	if !isTransitionAllowed(current, req.Status) {
		reason := fmt.Sprintf("„Äå%s„Äç„Åã„Çâ„Äå%s„Äç„Å∏„ÅÆÂ§âÊõ¥„ÅØË®±ÂèØ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì", defaultStatusLabel(current), defaultStatusLabel(req.Status))
		return StatusUpdateResult{}, &StatusTransitionError{From: current, To: req.Status, Reason: reason}
	}

	note := strings.TrimSpace(req.Note)
	now := time.Now()

	order.Status = req.Status
	order.StatusLabel = defaultStatusLabel(req.Status)
	order.StatusTone = defaultStatusTone(req.Status)
	order.UpdatedAt = now

	if note != "" {
		formatted := note
		actor := strings.TrimSpace(req.ActorEmail)
		if actor != "" {
			formatted = actor + ": " + note
		}
		order.Notes = append([]string{formatted}, order.Notes...)
	}

	if req.Status == StatusRefunded {
		order.HasRefundRequest = true
		order.Payment.Status = "ËøîÈáëÊ∏à„Åø"
		order.Payment.StatusTone = "info"
	}

	switch req.Status {
	case StatusInProduction:
		order.Fulfillment.SLAStatus = "Âà∂‰ΩúÈÄ≤Ë°å‰∏≠"
		order.Fulfillment.SLAStatusTone = "info"
	case StatusReadyToShip:
		order.Fulfillment.SLAStatus = "ÈõÜËç∑ÂæÖ„Å°"
		order.Fulfillment.SLAStatusTone = "info"
	case StatusShipped:
		order.Fulfillment.DispatchedAt = timePtr(now)
		order.Fulfillment.SLAStatus = "ÈÖçÈÄÅ‰∏≠"
		order.Fulfillment.SLAStatusTone = "info"
	case StatusDelivered:
		order.Fulfillment.DeliveredAt = timePtr(now)
		order.Fulfillment.SLAStatus = "Á¥çÂìÅÊ∏à„Åø"
		order.Fulfillment.SLAStatusTone = "success"
	case StatusCancelled:
		order.Fulfillment.SLAStatus = "„Ç≠„É£„É≥„Çª„É´Ê∏à„Åø"
		order.Fulfillment.SLAStatusTone = "muted"
	}

	s.orders[idx] = *order

	actor := strings.TrimSpace(req.ActorEmail)
	if actor == "" {
		actor = "„Ç™„Éö„É¨„Éº„Çø„Éº"
	}

	description := buildTimelineDescription(note, req.NotifyCustomer)
	event := TimelineEvent{
		ID:          fmt.Sprintf("%s-%d", orderID, now.UnixNano()),
		Status:      req.Status,
		Title:       fmt.Sprintf("„Çπ„ÉÜ„Éº„Çø„Çπ„Çí„Äå%s„Äç„Å´Êõ¥Êñ∞", defaultStatusLabel(req.Status)),
		Description: description,
		Actor:       actor,
		OccurredAt:  now,
	}
	s.timelines[orderID] = append(s.timelines[orderID], event)

	if s.audit != nil {
		_ = s.audit.Record(ctx, AuditLogEntry{
			OrderID:     order.ID,
			OrderNumber: order.Number,
			Action:      "orders.status.transition",
			ActorID:     strings.TrimSpace(req.ActorID),
			ActorEmail:  strings.TrimSpace(req.ActorEmail),
			FromStatus:  current,
			ToStatus:    req.Status,
			Note:        note,
			OccurredAt:  now,
		})
	}

	updated := cloneOrder(*order)
	timeline := cloneTimeline(s.timelines[orderID])

	return StatusUpdateResult{Order: updated, Timeline: timeline}, nil
}

// SubmitRefund mutates the payment state with a simulated refund.
func (s *StaticService) SubmitRefund(ctx context.Context, _ string, orderID string, req RefundRequest) (RefundResult, error) {
	paymentID := strings.TrimSpace(req.PaymentID)
	if paymentID == "" {
		return RefundResult{}, &RefundValidationError{
			Message:     "ËøîÈáëÂØæË±°„ÅÆÊîØÊâï„ÅÑ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
			FieldErrors: map[string]string{"paymentID": "ËøîÈáëÂØæË±°„ÅÆÊîØÊâï„ÅÑ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"},
		}
	}
	if req.AmountMinor <= 0 {
		return RefundResult{}, &RefundValidationError{
			Message:     "ËøîÈáëÈáëÈ°ç„ÇíÊ≠£„Åó„ÅèÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
			FieldErrors: map[string]string{"amount": "1ÂÜÜ‰ª•‰∏ä„ÅÆÈáëÈ°ç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"},
		}
	}
	reason := strings.TrimSpace(req.Reason)
	if reason == "" {
		return RefundResult{}, &RefundValidationError{
			Message:     "ËøîÈáëÁêÜÁî±„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
			FieldErrors: map[string]string{"reason": "ËøîÈáëÁêÜÁî±„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"},
		}
	}

	s.mu.Lock()
	defer s.mu.Unlock()

	idx, order := s.findOrderLocked(orderID)
	if order == nil {
		return RefundResult{}, ErrOrderNotFound
	}

	payment := findPayment(order, paymentID)
	if payment == nil {
		return RefundResult{}, ErrPaymentNotFound
	}

	if payment.AmountCaptured <= 0 {
		return RefundResult{}, &RefundValidationError{
			Message:     "„Åì„ÅÆÊîØÊâï„ÅÑ„ÅØ„Åæ„Å†Á¢∫ÂÆö„Åó„Å¶„ÅÑ„Å™„ÅÑ„Åü„ÇÅËøîÈáë„Åß„Åç„Åæ„Åõ„Çì„ÄÇ",
			FieldErrors: map[string]string{"paymentID": "„Åì„ÅÆÊîØÊâï„ÅÑ„ÅØËøîÈáë„Åß„Åç„Åæ„Åõ„Çì„ÄÇ"},
		}
	}
	if payment.AmountAvailable <= 0 {
		return RefundResult{}, &RefundValidationError{
			Message:     "ËøîÈáëÂèØËÉΩ„Å™ÈáëÈ°ç„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
			FieldErrors: map[string]string{"amount": "ËøîÈáëÂèØËÉΩ„Å™ÈáëÈ°ç„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ"},
		}
	}
	if req.AmountMinor > payment.AmountAvailable {
		return RefundResult{}, &RefundValidationError{
			Message:     "ËøîÈáëÂèØËÉΩÈ°ç„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
			FieldErrors: map[string]string{"amount": "ËøîÈáëÂèØËÉΩÈ°ç„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ"},
		}
	}

	now := time.Now()
	payment.AmountRefunded += req.AmountMinor
	if payment.AmountRefunded > payment.AmountCaptured {
		payment.AmountRefunded = payment.AmountCaptured
	}
	payment.AmountAvailable = payment.AmountCaptured - payment.AmountRefunded
	if payment.AmountAvailable < 0 {
		payment.AmountAvailable = 0
	}

	currency := strings.TrimSpace(req.Currency)
	if currency == "" {
		if payment.Currency != "" {
			currency = payment.Currency
		} else {
			currency = order.Currency
		}
	}

	actor := strings.TrimSpace(req.ActorEmail)
	if actor == "" {
		actor = "„Ç™„Éö„É¨„Éº„Çø„Éº"
	}

	refID := fmt.Sprintf("refund_%s_%d", payment.ID, now.UnixNano())
	refund := RefundRecord{
		ID:          refID,
		PaymentID:   payment.ID,
		AmountMinor: req.AmountMinor,
		Currency:    currency,
		Reason:      reason,
		Status:      "succeeded",
		ProcessedAt: now,
		Actor:       actor,
		Reference:   refID,
	}
	order.Refunds = append([]RefundRecord{refund}, order.Refunds...)

	order.HasRefundRequest = true
	order.Payment.StatusTone = "info"
	if payment.AmountAvailable == 0 {
		order.Payment.Status = "ËøîÈáëÊ∏à„Åø"
	} else {
		order.Payment.Status = "‰∏ÄÈÉ®ËøîÈáë"
	}
	order.UpdatedAt = now

	if reason != "" {
		formatted := reason
		if actor != "" {
			formatted = actor + ": " + reason
		}
		order.Notes = append([]string{formatted}, order.Notes...)
	}

	if s.timelines != nil {
		description := fmt.Sprintf("%s „ÇíËøîÈáë (%s)", formatMinorAmount(req.AmountMinor, currency), reason)
		event := TimelineEvent{
			ID:          fmt.Sprintf("%s-refund-%d", orderID, now.UnixNano()),
			Status:      order.Status,
			Title:       "ËøîÈáë„ÇíÁôªÈå≤",
			Description: strings.TrimSpace(description),
			Actor:       actor,
			OccurredAt:  now,
		}
		s.timelines[orderID] = append(s.timelines[orderID], event)
	}

	paymentOption := toRefundPaymentOption(*payment)
	paymentOptions := make([]RefundPaymentOption, 0, len(order.Payments))
	for _, p := range order.Payments {
		paymentOptions = append(paymentOptions, toRefundPaymentOption(p))
	}

	s.orders[idx] = *order

	return RefundResult{
		Refund:   refund,
		Payment:  paymentOption,
		Payments: paymentOptions,
	}, nil
}

type invoiceJobState struct {
	OrderID   string
	InvoiceID string
	Job       InvoiceJob
	Completed bool
	Attempts  int
}

type exportJobState struct {
	Job       ExportJob
	Completed bool
	Attempts  int
}

func (s *StaticService) findOrderLocked(orderID string) (int, *Order) {
	for i := range s.orders {
		if s.orders[i].ID == orderID {
			return i, &s.orders[i]
		}
	}
	return -1, nil
}

func findPayment(order *Order, paymentID string) *PaymentDetail {
	if order == nil {
		return nil
	}
	for i := range order.Payments {
		if order.Payments[i].ID == paymentID {
			return &order.Payments[i]
		}
	}
	return nil
}

func toRefundPaymentOption(payment PaymentDetail) RefundPaymentOption {
	return RefundPaymentOption{
		ID:              payment.ID,
		Label:           buildPaymentLabel(payment),
		Method:          payment.Method,
		Reference:       payment.Reference,
		Status:          payment.Status,
		StatusTone:      payment.StatusTone,
		Currency:        payment.Currency,
		CapturedMinor:   payment.AmountCaptured,
		RefundedMinor:   payment.AmountRefunded,
		AvailableMinor:  payment.AmountAvailable,
		CapturedAt:      payment.CapturedAt,
		SupportsRefunds: payment.AmountAvailable > 0,
	}
}

func buildPaymentLabel(payment PaymentDetail) string {
	parts := []string{}
	if trimmed := strings.TrimSpace(payment.Provider); trimmed != "" {
		parts = append(parts, trimmed)
	}
	if method := strings.TrimSpace(payment.Method); method != "" {
		parts = append(parts, method)
	}
	if last4 := strings.TrimSpace(payment.Last4); last4 != "" {
		if !strings.HasPrefix(last4, "****") && len(last4) <= 4 {
			parts = append(parts, "****"+last4)
		} else {
			parts = append(parts, last4)
		}
	}
	if len(parts) == 0 {
		return "ÊîØÊâï„ÅÑ"
	}
	return strings.Join(parts, " ")
}

func formatMinorAmount(amount int64, currency string) string {
	sign := ""
	if amount < 0 {
		sign = "-"
		amount = -amount
	}
	major := amount / 100
	minor := amount % 100
	code := strings.ToUpper(strings.TrimSpace(currency))
	if code == "" {
		return fmt.Sprintf("%s%d.%02d", sign, major, minor)
	}
	return fmt.Sprintf("%s%d.%02d %s", sign, major, minor, code)
}

func buildStatusChoices(current Status) []StatusTransitionOption {
	allowed := map[Status]bool{}
	for _, next := range statusTransitionGraph[current] {
		allowed[next] = true
	}

	choices := make([]StatusTransitionOption, 0, len(orderedStatuses()))
	for _, candidate := range orderedStatuses() {
		choice := StatusTransitionOption{
			Value:       candidate,
			Label:       defaultStatusLabel(candidate),
			Description: StatusDescription(candidate),
			Selected:    candidate == current,
		}
		if candidate == current {
			choice.Disabled = true
			choice.DisabledReason = "ÁèæÂú®„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„Åß„Åô"
		} else if !allowed[candidate] {
			choice.Disabled = true
			choice.DisabledReason = fmt.Sprintf("„Äå%s„Äç„Åã„Çâ„Äå%s„Äç„Å∏„ÅØÈÅ∑Áßª„Åß„Åç„Åæ„Åõ„Çì", defaultStatusLabel(current), defaultStatusLabel(candidate))
		}
		choices = append(choices, choice)
	}
	return choices
}

func isTransitionAllowed(from, to Status) bool {
	if from == to {
		return false
	}
	for _, candidate := range statusTransitionGraph[from] {
		if candidate == to {
			return true
		}
	}
	return false
}

func buildTimelineDescription(note string, notify bool) string {
	parts := []string{}
	trimmed := strings.TrimSpace(note)
	if trimmed != "" {
		parts = append(parts, trimmed)
	}
	if notify {
		parts = append(parts, "È°ßÂÆ¢„Å´ÈÄöÁü•„ÇíÈÄÅ‰ø°„Åó„Åæ„Åó„Åü")
	}
	return strings.Join(parts, " / ")
}

var statusTransitionGraph = map[Status][]Status{
	StatusPendingPayment: {StatusPaymentReview, StatusInProduction, StatusCancelled},
	StatusPaymentReview:  {StatusInProduction, StatusCancelled},
	StatusInProduction:   {StatusReadyToShip, StatusCancelled},
	StatusReadyToShip:    {StatusShipped, StatusCancelled},
	StatusShipped:        {StatusDelivered, StatusRefunded},
	StatusDelivered:      {StatusRefunded},
	StatusCancelled:      {StatusRefunded},
	StatusRefunded:       {},
}

func filterOrders(orders []Order, query Query, includeStatus bool) []Order {
	results := make([]Order, 0, len(orders))

	statusSet := map[Status]bool{}
	if includeStatus && len(query.Statuses) > 0 {
		for _, status := range query.Statuses {
			statusSet[status] = true
		}
	}

	trimmedCurrency := strings.TrimSpace(query.Currency)

	for _, order := range orders {
		if includeStatus && len(statusSet) > 0 && !statusSet[order.Status] {
			continue
		}
		if query.Since != nil && order.UpdatedAt.Before(*query.Since) {
			continue
		}
		if trimmedCurrency != "" && !strings.EqualFold(order.Currency, trimmedCurrency) {
			continue
		}
		if query.AmountMin != nil && order.TotalMinor < *query.AmountMin {
			continue
		}
		if query.AmountMax != nil && order.TotalMinor > *query.AmountMax {
			continue
		}
		if query.HasRefundOnly != nil {
			if *query.HasRefundOnly && !order.HasRefundRequest {
				continue
			}
			if !*query.HasRefundOnly && order.HasRefundRequest {
				continue
			}
		}
		results = append(results, order)
	}

	return results
}

func sortOrders(orders []Order, query Query) {
	sortKey := strings.ToLower(strings.TrimSpace(query.SortKey))
	sortDir := strings.ToLower(string(query.SortDirection))
	desc := true
	if sortDir == string(SortDirectionAsc) {
		desc = false
	}

	if sortKey == "" {
		sortKey = "updated_at"
	}

	sort.SliceStable(orders, func(i, j int) bool {
		a := orders[i]
		b := orders[j]

		var less bool
		switch sortKey {
		case "total":
			if a.TotalMinor == b.TotalMinor {
				less = a.Number < b.Number
			} else {
				less = a.TotalMinor < b.TotalMinor
			}
		case "status":
			ra := statusSortRank(a.Status)
			rb := statusSortRank(b.Status)
			if ra == rb {
				less = strings.Compare(strings.ToLower(strings.TrimSpace(a.StatusLabel)), strings.ToLower(strings.TrimSpace(b.StatusLabel))) < 0
			} else {
				less = ra < rb
			}
		case "number":
			less = a.Number < b.Number
		default: // updated_at
			less = a.UpdatedAt.Before(b.UpdatedAt)
		}

		if desc {
			return !less
		}
		return less
	})
}

func buildSummary(orders []Order) Summary {
	var revenue int64
	var leadHours float64
	var leadCount float64
	var delayed int
	var refunds int
	var inProduction int
	var fulfilled24h int

	now := time.Now()

	for _, order := range orders {
		revenue += order.TotalMinor
		if order.Fulfillment.SLAStatusTone == "danger" {
			delayed++
		}
		if order.HasRefundRequest {
			refunds++
		}
		if order.Status == StatusInProduction {
			inProduction++
		}
		if order.Fulfillment.DispatchedAt != nil {
			lead := order.Fulfillment.DispatchedAt.Sub(order.CreatedAt).Hours()
			if lead < 0 {
				lead = 0
			}
			leadHours += lead
			leadCount++
			if now.Sub(*order.Fulfillment.DispatchedAt) <= 24*time.Hour {
				fulfilled24h++
			}
		}
	}

	avgLead := 0.0
	if leadCount > 0 {
		avgLead = leadHours / leadCount
	}

	distribution := statusDistribution(orders)

	return Summary{
		TotalOrders:        len(orders),
		TotalRevenueMinor:  revenue,
		AverageLeadHours:   avgLead,
		DelayedCount:       delayed,
		RefundRequested:    refunds,
		InProductionCount:  inProduction,
		FulfilledLast24h:   fulfilled24h,
		LastRefreshedAt:    now,
		PrimaryCurrency:    primaryCurrency(orders),
		StatusDistribution: distribution,
	}
}

func statusDistribution(orders []Order) []StatusCount {
	counts := map[Status]int{}
	for _, order := range orders {
		counts[order.Status]++
	}
	allStatuses := orderedStatuses()

	result := make([]StatusCount, 0, len(allStatuses))
	for _, st := range allStatuses {
		result = append(result, StatusCount{Status: st, Count: counts[st]})
	}
	return result
}

func primaryCurrency(orders []Order) string {
	counts := map[string]int{}
	var best string
	bestCount := -1
	for _, order := range orders {
		cur := strings.ToUpper(strings.TrimSpace(order.Currency))
		if cur == "" {
			continue
		}
		counts[cur]++
		if counts[cur] > bestCount {
			best = cur
			bestCount = counts[cur]
		}
	}
	if best == "" {
		return "JPY"
	}
	return best
}

func buildFilterSummary(orders []Order, query Query) FilterSummary {
	withoutStatus := filterOrders(orders, query, false)

	statusCounts := map[Status]int{}
	for _, order := range withoutStatus {
		statusCounts[order.Status]++
	}

	statusOptions := []StatusOption{
		{Value: StatusPendingPayment, Label: "ÊîØÊâï„ÅÑÂæÖ„Å°"},
		{Value: StatusPaymentReview, Label: "ÊîØÊâï„ÅÑÁ¢∫Ë™ç‰∏≠"},
		{Value: StatusInProduction, Label: "Âà∂‰Ωú‰∏≠"},
		{Value: StatusReadyToShip, Label: "Âá∫Ëç∑ÂæÖ„Å°"},
		{Value: StatusShipped, Label: "Áô∫ÈÄÅÊ∏à„Åø"},
		{Value: StatusDelivered, Label: "Á¥çÂìÅÊ∏à„Åø"},
		{Value: StatusRefunded, Label: "ËøîÈáëÊ∏à„Åø"},
		{Value: StatusCancelled, Label: "„Ç≠„É£„É≥„Çª„É´"},
	}
	for i := range statusOptions {
		statusOptions[i].Count = statusCounts[statusOptions[i].Value]
		statusOptions[i].Description = statusOptions[i].Label
	}

	currencyCounts := map[string]int{}
	for _, order := range withoutStatus {
		code := strings.ToUpper(strings.TrimSpace(order.Currency))
		if code == "" {
			continue
		}
		currencyCounts[code]++
	}
	currencyOptions := make([]CurrencyOption, 0, len(currencyCounts))
	for code, count := range currencyCounts {
		label := code
		if code == "JPY" {
			label = "JPYÔºàÊó•Êú¨ÂÜÜÔºâ"
		} else if code == "USD" {
			label = "USDÔºàÁ±≥„Éâ„É´Ôºâ"
		}
		currencyOptions = append(currencyOptions, CurrencyOption{
			Code:  code,
			Label: label,
			Count: count,
		})
	}
	sort.Slice(currencyOptions, func(i, j int) bool {
		return currencyOptions[i].Code < currencyOptions[j].Code
	})

	refundOptions := []RefundOption{
		{Value: "", Label: "„Åô„Åπ„Å¶"},
		{Value: "true", Label: "ËøîÈáëÁî≥Ë´ã„ÅÇ„Çä"},
		{Value: "false", Label: "ËøîÈáëÁî≥Ë´ã„Å™„Åó"},
	}

	amountRanges := []AmountRange{
		{Label: "¬•0 - ¬•10,000", Min: int64Ptr(0), Max: int64Ptr(1000000)},
		{Label: "¬•10,000 - ¬•30,000", Min: int64Ptr(1000000), Max: int64Ptr(3000000)},
		{Label: "¬•30,000+", Min: int64Ptr(3000000), Max: nil},
	}

	return FilterSummary{
		StatusOptions:   statusOptions,
		CurrencyOptions: currencyOptions,
		RefundOptions:   refundOptions,
		AmountRanges:    amountRanges,
	}
}

func defaultStatusLabel(status Status) string {
	switch status {
	case StatusPendingPayment:
		return "ÊîØÊâï„ÅÑÂæÖ„Å°"
	case StatusPaymentReview:
		return "ÊîØÊâï„ÅÑÁ¢∫Ë™ç‰∏≠"
	case StatusInProduction:
		return "Âà∂‰Ωú‰∏≠"
	case StatusReadyToShip:
		return "Âá∫Ëç∑ÂæÖ„Å°"
	case StatusShipped:
		return "Áô∫ÈÄÅÊ∏à„Åø"
	case StatusDelivered:
		return "Á¥çÂìÅÊ∏à„Åø"
	case StatusRefunded:
		return "ËøîÈáëÊ∏à„Åø"
	case StatusCancelled:
		return "„Ç≠„É£„É≥„Çª„É´"
	default:
		return "„Åù„ÅÆ‰ªñ"
	}
}

func defaultStatusTone(status Status) string {
	switch status {
	case StatusPendingPayment, StatusPaymentReview:
		return "warning"
	case StatusInProduction, StatusReadyToShip:
		return "info"
	case StatusShipped:
		return "info"
	case StatusDelivered:
		return "success"
	case StatusRefunded, StatusCancelled:
		return "muted"
	default:
		return "info"
	}
}

func seedTimeline(order Order) []TimelineEvent {
	statuses := orderedStatuses()
	index := len(statuses) - 1
	for i, st := range statuses {
		if st == order.Status {
			index = i
			break
		}
	}

	base := order.CreatedAt
	if base.IsZero() {
		base = time.Now().Add(-48 * time.Hour)
	}
	step := 3 * time.Hour
	current := base

	events := make([]TimelineEvent, 0, index+2)
	events = append(events, TimelineEvent{
		ID:          fmt.Sprintf("%s-created", order.ID),
		Status:      StatusPendingPayment,
		Title:       "Ê≥®Êñá„Çí‰ΩúÊàê",
		Description: fmt.Sprintf("Ê≥®Êñá #%s „ÇíÂèó„Åë‰ªò„Åë„Åæ„Åó„Åü", strings.TrimSpace(order.Number)),
		Actor:       "„Ç∑„Çπ„ÉÜ„É†",
		OccurredAt:  base,
	})

	for i := 0; i <= index && i < len(statuses); i++ {
		current = current.Add(step)
		status := statuses[i]
		events = append(events, TimelineEvent{
			ID:          fmt.Sprintf("%s-%s-%d", order.ID, status, i),
			Status:      status,
			Title:       fmt.Sprintf("„Çπ„ÉÜ„Éº„Çø„Çπ„Çí„Äå%s„Äç„Å´Êõ¥Êñ∞", defaultStatusLabel(status)),
			Description: StatusDescription(status),
			Actor:       "„Ç∑„Çπ„ÉÜ„É†",
			OccurredAt:  current,
		})
	}

	if len(events) > 0 {
		final := &events[len(events)-1]
		if !order.UpdatedAt.IsZero() {
			final.OccurredAt = order.UpdatedAt
		}
	}

	return events
}

type noopAuditLogger struct{}

func (noopAuditLogger) Record(_ context.Context, _ AuditLogEntry) error { return nil }

func int64Ptr(value int64) *int64 {
	return &value
}

func timePtr(t time.Time) *time.Time {
	return &t
}

func orderedStatuses() []Status {
	return []Status{
		StatusPendingPayment,
		StatusPaymentReview,
		StatusInProduction,
		StatusReadyToShip,
		StatusShipped,
		StatusDelivered,
		StatusRefunded,
		StatusCancelled,
	}
}

func statusSortRank(status Status) int {
	for idx, candidate := range orderedStatuses() {
		if candidate == status {
			return idx
		}
	}
	return len(orderedStatuses())
}
