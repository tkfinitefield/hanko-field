name: API CI/CD

on:
  pull_request:
    paths:
      - 'api/**'
      - '.github/workflows/api.yml'
  push:
    branches:
      - main
    paths:
      - 'api/**'
      - '.github/workflows/api.yml'

env:
  GO_VERSION: '1.21'
  API_DIR: api

jobs:
  checks:
    name: Lint, Test, and Coverage
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'push'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          cache-dependency-path: |
            api/go.sum
            api/tools/tools.go

      - name: Install toolchain
        working-directory: ${{ env.API_DIR }}
        run: make deps

      - name: Verify formatting
        working-directory: ${{ env.API_DIR }}
        run: make fmt-check

      - name: Run static analysis
        working-directory: ${{ env.API_DIR }}
        run: make lint

      - name: Run unit tests with coverage
        working-directory: ${{ env.API_DIR }}
        run: go test ./... -covermode=atomic -coverprofile=coverage.unit.out

      - name: Start Firestore emulator
        run: |
          docker pull gcr.io/google.com/cloudsdktool/cloud-sdk:emulators
          docker run -d --name firestore-emulator -p 8080:8080 gcr.io/google.com/cloudsdktool/cloud-sdk:emulators gcloud beta emulators firestore start --host-port=0.0.0.0:8080 --quiet
          sleep 10

      - name: Run Firestore integration tests
        working-directory: ${{ env.API_DIR }}
        env:
          FIRESTORE_EMULATOR_HOST: 127.0.0.1:8080
          GOOGLE_CLOUD_PROJECT: hanko-field-ci
        run: go test ./... -tags=integration -count=1 -covermode=atomic -coverprofile=coverage.integration.out

      - name: Stop Firestore emulator
        if: always()
        run: docker rm -f firestore-emulator

      - name: Merge coverage profiles
        working-directory: ${{ env.API_DIR }}
        run: ./bin/gocovmerge coverage.unit.out coverage.integration.out > coverage.out

      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: api-coverage-${{ github.run_id }}
          path: ${{ env.API_DIR }}/coverage.out

  build-and-deploy-staging:
    name: Build and Deploy to Staging
    runs-on: ubuntu-latest
    needs: checks
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: staging
    env:
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GAR_LOCATION: ${{ secrets.GAR_LOCATION }}
      GAR_REPOSITORY: ${{ secrets.GAR_REPOSITORY }}
      CLOUD_RUN_REGION: ${{ secrets.CLOUD_RUN_REGION }}
      CLOUD_RUN_SERVICE: ${{ secrets.CLOUD_RUN_SERVICE }}
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      STAGING_SMOKE_URL: ${{ secrets.STAGING_SMOKE_URL }}
      IMAGE_TAG: ${{ github.sha }}
    outputs:
      image-uri: ${{ steps.package.outputs.image-uri }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up gcloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure Artifact Registry authentication
        run: gcloud auth configure-docker "${GAR_LOCATION}-docker.pkg.dev" --quiet

      - name: Build container image
        working-directory: ${{ env.API_DIR }}
        env:
          GAR_HOST: ${{ env.GAR_LOCATION }}-docker.pkg.dev
        run: |
          IMAGE_URI="${GAR_HOST}/${GCP_PROJECT_ID}/${GAR_REPOSITORY}/api:${IMAGE_TAG}"
          echo "IMAGE_URI=${IMAGE_URI}" >> $GITHUB_ENV
          docker build --target runner -t "${IMAGE_URI}" .

      - name: Push container image
        env:
          IMAGE_URI: ${{ env.IMAGE_URI }}
        run: docker push "${IMAGE_URI}"

      - name: Package metadata
        id: package
        env:
          IMAGE_URI: ${{ env.IMAGE_URI }}
        run: |
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          cat <<EOF > deployment-metadata.json
          {
            "commit": "${GITHUB_SHA}",
            "image": "${IMAGE_URI}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "environment": "staging"
          }
          EOF

      - name: Capture current revision
        id: current-revision
        run: |
          gcloud run services describe "${CLOUD_RUN_SERVICE}" \
            --platform=managed \
            --region="${CLOUD_RUN_REGION}" \
            --format="value(status.latestReadyRevisionName)" > previous_revision.txt || true
          if [ -s previous_revision.txt ]; then
            echo "previous-revision=$(cat previous_revision.txt)" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to Cloud Run (staging)
        run: |
          gcloud run deploy "${CLOUD_RUN_SERVICE}" \
            --platform=managed \
            --region="${CLOUD_RUN_REGION}" \
            --project="${GCP_PROJECT_ID}" \
            --image="${IMAGE_URI}" \
            --set-env-vars=GOOGLE_CLOUD_PROJECT=${GCP_PROJECT_ID} \
            --labels=commit=${GITHUB_SHA},env=staging \
            --tag=staging \
            --quiet

      - name: Retrieve service URL
        id: service-url
        run: |
          URL=$(gcloud run services describe "${CLOUD_RUN_SERVICE}" \
            --platform=managed \
            --region="${CLOUD_RUN_REGION}" \
            --project="${GCP_PROJECT_ID}" \
            --format="value(status.url)")
          echo "url=${URL}" >> $GITHUB_OUTPUT

      - name: Run staging smoke test
        env:
          SMOKE_URL: ${{ env.STAGING_SMOKE_URL }}
          FALLBACK_URL: ${{ steps.service-url.outputs.url }}
        run: |
          TARGET="${SMOKE_URL:-$FALLBACK_URL}"/healthz
          for attempt in 1 2 3 4 5; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET")
            if [ "$STATUS" = "200" ]; then
              echo "Smoke test passed"
              exit 0
            fi
            echo "Attempt ${attempt} failed with status ${STATUS}; retrying"
            sleep 5
          done
          echo "Smoke test failed"
          exit 1

      - name: Upload deployment metadata
        uses: actions/upload-artifact@v4
        with:
          name: api-staging-deploy-${{ github.run_id }}
          path: |
            deployment-metadata.json
            previous_revision.txt

      - name: Notify Slack (staging)
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          WEBHOOK_URL: ${{ env.SLACK_WEBHOOK_URL }}
          SERVICE_URL: ${{ steps.service-url.outputs.url }}
        run: |
          payload=$(jq -n --arg env "staging" --arg url "$SERVICE_URL" --arg sha "${GITHUB_SHA}" '{text: "API deployed to " + $env + " (" + $url + ") for commit " + $sha}')
          curl -X POST -H "Content-type: application/json" --data "$payload" "$WEBHOOK_URL"

  promote-production:
    name: Promote to Production
    runs-on: ubuntu-latest
    needs: build-and-deploy-staging
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: production
    env:
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GAR_LOCATION: ${{ secrets.GAR_LOCATION }}
      GAR_REPOSITORY: ${{ secrets.GAR_REPOSITORY }}
      CLOUD_RUN_REGION: ${{ secrets.CLOUD_RUN_REGION }}
      CLOUD_RUN_SERVICE: ${{ secrets.CLOUD_RUN_SERVICE }}
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      PRODUCTION_SMOKE_URL: ${{ secrets.PRODUCTION_SMOKE_URL }}
      IMAGE_URI: ${{ needs.build-and-deploy-staging.outputs.image-uri }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up gcloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Capture current production revision
        id: prod-current
        run: |
          gcloud run services describe "${CLOUD_RUN_SERVICE}" \
            --platform=managed \
            --region="${CLOUD_RUN_REGION}" \
            --project="${GCP_PROJECT_ID}" \
            --format="value(status.latestReadyRevisionName)" > production_previous_revision.txt || true
          if [ -s production_previous_revision.txt ]; then
            echo "previous-revision=$(cat production_previous_revision.txt)" >> $GITHUB_OUTPUT
          fi

      - name: Deploy image to production
        env:
          IMAGE_URI: ${{ env.IMAGE_URI }}
        run: |
          gcloud run deploy "${CLOUD_RUN_SERVICE}" \
            --platform=managed \
            --region="${CLOUD_RUN_REGION}" \
            --project="${GCP_PROJECT_ID}" \
            --image="${IMAGE_URI}" \
            --set-env-vars=GOOGLE_CLOUD_PROJECT=${GCP_PROJECT_ID} \
            --labels=commit=${GITHUB_SHA},env=production \
            --traffic=100 \
            --quiet

      - name: Retrieve production service URL
        id: prod-url
        run: |
          URL=$(gcloud run services describe "${CLOUD_RUN_SERVICE}" \
            --platform=managed \
            --region="${CLOUD_RUN_REGION}" \
            --project="${GCP_PROJECT_ID}" \
            --format="value(status.url)")
          echo "url=${URL}" >> $GITHUB_OUTPUT

      - name: Run production smoke test
        env:
          SMOKE_URL: ${{ env.PRODUCTION_SMOKE_URL }}
          FALLBACK_URL: ${{ steps.prod-url.outputs.url }}
        run: |
          TARGET="${SMOKE_URL:-$FALLBACK_URL}"/healthz
          for attempt in 1 2 3 4 5; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET")
            if [ "$STATUS" = "200" ]; then
              echo "Smoke test passed"
              exit 0
            fi
            echo "Attempt ${attempt} failed with status ${STATUS}; retrying"
            sleep 5
          done
          echo "Smoke test failed"
          exit 1

      - name: Upload production deployment metadata
        uses: actions/upload-artifact@v4
        with:
          name: api-production-deploy-${{ github.run_id }}
          path: |
            production_previous_revision.txt

      - name: Notify Slack (production)
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          WEBHOOK_URL: ${{ env.SLACK_WEBHOOK_URL }}
          SERVICE_URL: ${{ steps.prod-url.outputs.url }}
        run: |
          payload=$(jq -n --arg env "production" --arg url "$SERVICE_URL" --arg sha "${GITHUB_SHA}" '{text: "API deployed to " + $env + " (" + $url + ") for commit " + $sha}')
          curl -X POST -H "Content-type: application/json" --data "$payload" "$WEBHOOK_URL"
